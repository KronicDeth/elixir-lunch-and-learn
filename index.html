<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Lunch and Learn - Elixir</title>

		<meta name="description" content="Lunch and Learn at Rapid7 Austin on Elixir">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Lunch and Learn</h1>
                    <h2>Elixir</h2>
                    <p>Luke Imhoff</p>
                    <table>
                        <tbody>
                        <tr>
                            <th>
                                <svg
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px" viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                            <g>
                                                <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                                <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                                <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                                <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                            </g>
                                        </svg>
                            </th>
                            <td>luke_imhoff@rapid7.com</td>
                            <td>Kronic.Deth@gmail.com</td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="github-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                                        </svg>
                            </th>
                            <td>
                                <a href="https://github.com/limhoff-r7" target="_blank">@limhoff-r7</a>
                            </td>
                            <td>
                                <a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
                            </th>
                            <td></td>
                            <td>
                                <a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        I am a Senior Software Engineer for Metasploit Applications at Rapid7
                    </aside>
                </section>
                <section>
                    <h1>Outline</h1>
                    <ol>
                        <li><a href="#/functional-languages">Functional Languages</a></li>
                        <li><a href="#/erlang">Erlang</a></li>
                        <li><a href="#/why-elixir-and-not-erlang">Why Elixir and not Erlang?</a></li>
                        <li><a href="#/wow">Wow!</a></li>
                        <li><a href="#/resources">Resources</a></li>
                    </ol>
                </section>
                <section class="stack">
                    <section id="functional-languages">
                        <h1>Functional Languages</h1>
                    </section>
                    <section>
                        <h1>What is a functional language?</h1>
                        <ul>
                            <li>Mathematical functions</li>
                            <li>Avoids changing state</li>
                            <li>Immutable data</li>
                        </ul>
                        <aside class="notes">
                            The output of a mathematical function depends only only on its inputs.  This makes
                            mathematical functions easier to reason about because you can just substitute the output
                            for the function call. Pure functional languages, like Haskell completely avoid changing
                            state by encapsulating state changes in their data, but Erlang and Elixir are not pure like
                            Haskell.
                        </aside>
                    </section>
                    <section>
                        <h1>Advantages of functional languages</h1>
                        <ul>
                            <li>Lack of shared, mutable state</li>
                            <li>Immutable data</li>
                        </ul>
                        <aside class="notes">
                            Immutable data means you don't have to worry about a function call changing your copy of
                            the arguments you pass to it.  Extending this across parallel threads, it means you don't
                            have to worry about race conditions and other threading bugs.
                        </aside>
                    </section>
                    <section>
                        <h1>(Perceived) disadvantages</h1>
                        <ul>
                            <li>Cryptic syntax</li>
                            <li>Harder to reason about immutability</li>
                            <li>Recursion + accumulation harder than iteration and mutation</li>
                            <li>It's not how I think</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Functional languages originated from Church's lambda calculus which is super cryptic
                                with only &lambda;, <code>x</code>, and <code>.</code>.  Other functional languages
                                like the Lisps, including Scheme and Clojure, use more parentheses than most people are
                                comfortable with. Haskell's syntax abstracts types and function arguments/returns and
                                drops parantheses.
                            </p>
                            <p>
                                Coming from an imperative and object oriented background we're so used to mutability
                                that we think of it as normal even though when we first learned it, mutability was odd
                                compared to math's fixed values for variables and pure functions.
                            </p>
                            <p>
                                Because most languages don't support tail call optimization or the lesser tail call
                                recursion, we've been trained to reach for the iterative solution to avoid stack
                                overflows, but a lot of problems in computing have much nicer recursive solutions.
                                With general tail call optimization, loops involving more than one function can be
                                represented in what would look like recursion.
                            </p>
                            <p>
                                Just as you learned imperative programming over mathematical thinking, you can retrain
                                to think in functional languages and even switch back and forth.  I currently switch
                                between Java, Ruby, and Elixir.  With only a few hiccups on namespace syntax and
                                string quoting.  If you're used to using <code>map</code> or <code>select</code> from
                                <code>Enumerable</code> in Ruby or the lambda expression features in Java 8, you are
                                already using functional programming.  If you ever used class methods in Ruby that
                                didn't write to class or instance variable.  Or, if you ever used static methods in
                                Java.  You're already using functional programming.
                            </p>
                            <p>
                                Learning functional programming will also prepare you for the future.  If you watch
                                conference talks in other langauges, such as Javascript or C++, languages are moving to
                                have more and more functional features as the programming community adapts to the
                                many-cores future.  They have figured out that locks, threads, and shared mutable
                                state is too error prone.
                            </p>
                            <p>
                                Moore's law increasing processor speed stopped 10 years ago. If you want to take
                                advantage of Moore's law now and in the future you need to write concurrent programs now
                                that can be parallelized across the additional cores of the future automatically.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="erlang">
                        <h1>Erlang</h1>
                        <aside class="notes">
                            Elixir runs on top of the BEAM Virtual Machine, which was originally designed for Erlang.
                            Much how Clojure and Scala run on the JVM, which was originally designed for Java.  Like
                            how Clojure and Scala can call Java code, Elixir can call Erlang code, so to understand
                            Elixir we need a little background on Erlang first.
                        </aside>
                    </section>
                    <section>
                        <h1>Facts</h1>
                        <ul>
                            <li>Developed for telecoms</li>
                            <li>Massively scalable</li>
                            <li>Hot code reloading</li>
                        </ul>
                        <aside class="notes">
                            Erlang was developed in 1986 at Ericsson by Joe Armstrong, Robert Virding and Mike Williams.
                            It was developed to run phone switches.  It needed to be able to update code without
                            dropping in progress calls and handle thousands of simultaneous connections using a single
                            embedded system from the late 80s.  It was written to show that replacing low-level C
                            for the phone switches would lead to more reliable software with a smaller code base, which
                            it did.
                        </aside>
                    </section>
                    <section>
                        <h1>Design Philosophy</h1>
                        <ul>
                            <li>Fault tolerant</li>
                            <li>Failures expected and embraced</li>
                            <li>Concurrency model is simple, but powerful</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Erlang is know for it's "Let It Crash!" motto, but letting code crash in the face of
                                software and hardware exceptions is not exactly what it means. Instead, Erlang supplies
                                VM-level processes.  In other languages, such as Ruby these would be green-threads,
                                which would be bad for performance and scheduling, but because Erlang is immutable, each
                                green-thread is completely isolated from the other green-threads, so much like OS
                                processes, the name process is apt because if an Erlang process crashes, just killing it
                                will clean everything up.
                            </p>
                            <p>
                                If a process is killed when it crashes how is state maintained?  Well, Erlang processes
                                can monitor each other so if one process crashes another is notified.  This pattern is
                                so useful that OTP, Erlang's standard library has a behavior (think abstract class or
                                interface) called a supervisor that monitors a process and restarts it when it dies.
                            </p>
                            <p>
                                Inside each process, code is written sequentially.  Processes communicate with each
                                other only by passing immutable messages.  This makes Erlang processes closer to the
                                idea for objects described in Alan Kay's original papers than objects in most
                                current Object-Oriented languages like Ruby.
                            </p>
                            <p>
                                Processes receive messages from a mailbox, which can be addressed even remotely if you
                                know the name.
                            </p>
                        </aside>
                    </section>
                    <section>
                        <h1>WhatsApp</h1>
                        <ul>
                            <li>2,277,845 simultaneous TCP connections</li>
                            <li>24 cores</li>
                            <li>1 Erlang VM</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                One of the recent success stories with Erlang is WhatsApp.  It was acquired by Facebook
                                in 2014.  In 2012 they were supporting over 2 million simultaneous connection on a
                                single machine using 24 cores.  The Erlang VM was able to schedule that many
                                simultaneous processes because there is only one OS thread for each scheduler and each
                                scheduler is assigned a core.  This keeps works from going across cores unless processes
                                want to communicate, but they message pass, so there's no shared memory issues with
                                caches or system memory like in other languages.
                            </p>
                            <p>
                                Besides, WhatApps, Erlang is being used in many MMOs as it allows easy coordination
                                because all the mobile users.  It is also used inside Heroku to manage their internal
                                network and routing.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="why-elixir-and-not-erlang">
                        <h1>Why Elixir and not Erlang?</h1>
                        <ul>
                            <li><a href="#/metaprogramming">Metaprogramming</a></li>
                            <li><a href="#/polymorphism">Polymorphism</a></li>
                            <li>Tooling</li>
                        </ul>
                    </section>
                </section>
                <section class="stack">
                    <section id="metaprogramming">
                        <h1>Erlang Macros vs Elixir Macros</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Erlang</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Run when?</td>
                                <td>Preprocess</td>
                                <td>Compile</td>
                            </tr>
                            <tr>
                                <td>Code generation</td>
                                <td>String substitution</td>
                                <td>AST manipulation</td>
                            </tr>
                            <tr>
                                <td>Language Features</td>
                                <td>Functions with Arguments</td>
                                <td>Full</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            When programming Ruby, we're used to being able to use blocks with class-level methods to
                            call and write DSLs to define code for us.  In Erlang, the macros can only do string
                            substitution like the C preprocessor, but Elixir gives access to the full language and
                            allows manipulating the Abstract Syntax Tree, which means we can delay execution just like
                            passing blocks in Ruby.
                        </aside>
                    </section>
                    <section>
                        <h1>Elixir Macros</h1>
                        <pre><code data-trim>
defmodule ElixirLunchAndLearnTest do
  use ExUnit.Case

  test "the truth" do
    assert 1 + 1 != 2
  end
end
                        </code></pre>
                        <aside class="notes">
                            Looking at this, it looks a lot like a DSL for ruby with <code>do</code>do blocks, but
                            <code>defmodule</code> is not a keyword in Elixir equivalent to <code>module</code> in Ruby
                            or <code>class</code> in Java, instead <code>defmodule</code> is a macro. Defined as normal
                            Elixir code that is run at compile time. The same with `use`, `test`, and `assert`.
                        </aside>
                    </section>
                    <section>
                        <h1>Capture Code</h1>
                        <img src="images/macros.png"/>
                        <aside class="notes">
                            With macros Elixir can do what most languages do with keywords, but those macros can
                            manipulate other code.  For example, the line with <code>assert</code> is able to give the
                            actual code run that got the error.
                        </aside>
                    </section>
                    <section>
                        <h2>Compile Data into Code</h2>
                        <pre class="stretch"><code data-trim>
defmodule MimeTypes do
  HTTPotion.start
  HTTPotion.Response[body: body] = HTTPotion.get(
    "http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
  )

  Enum.each String.split(body, %r/\n/), fn (line) ->
    unless line == "" or line =~ %r/^#/ do
      [ mimetype | _exts ] = String.split(line)


      def is_valid?(unquote(mimetype)), do: true
    end
  end

  def is_valid?(_mimetype), do: false
end

MimeTypes.is_valid?("application/vnd.exn") #=> false
MimeTypes.is_valid?("application/json")    #=> true
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Here, we download the list of know mime-types and create functions that match the known names.
                                This way, the compiler can optimize the lookup based on prefixes and we don't need to ship
                                and parse a file at runtime.
                            </p>
                            <p>
                                This approach is also used to enable Elixir to have full Unicode
                                support including proper support graphemes vs codepoints, such as when the accent is separate
                                from the character being accented.  Ruby doesn't handle this part of Unicode correctly, which
                                may become important as meterpreter adds unicode support.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="polymorphism">
                        <h1>Protocols</h1>
                        <ul>
                            <li>Allow extending functions to support new types</li>
                            <li>Support for protocol is separate from type definition</li>
                        </ul>
                        <aside class="notes">
                            In Ruby, we could monkey patch a class to support new methods.  In Java, reflection would
                            have to be used to add new methods to a pre-existing class or a method would need to be
                            implemented from an interface.  In Elixir, protocols can be defined that expose new methods
                            and then implementations of that protocol can be registered for different types, but
                            importantly, the protocol and type don't need to know about each other.  The implementation
                            can be done independently and Elixir will look it up and call it when using the protocol.
                        </aside>
                    </section>
                    <section>
                        <h1>Blank.blank?</h1>
                        <pre><code data-trim>
defprotocol Blank do
  @doc "Returns true if data is considered blank/empty"
  def blank?(data)
end
                        </code></pre>
                        <pre><code data-trim>
# Integers are never blank
defimpl Blank, for: Integer do
  def blank?(_), do: false
end

# Just empty list is blank
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end
                        </code></pre>
                        <aside class="notes">
                            Rails developers will recognize <code>blank?</code> from <code>ActiveSupport</code>.  In
                            Ruby, ActiveSupport must open up each class and add the <code>blank?</code> method to it,
                            but in Elixir we define separate implementation for each type.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="wow">
                        <h1>Wow!</h1>
                    </section>
                    <section>
                        <h1>Pipes</h1>
                    </section>
                    <section>
                        <h1>Pattern Matching Guards</h1>
                    </section>
                    <section>
                        <h1>Guards</h1>
                    </section>
                </section>
                <section class="stack">
                    <section>
                        <h1>Examples</h1>
                    </section>
                    <section>
                        <h1>Pattern Matching fizzbuzz</h1>
                    </section>
                    <section>
                        <h1>Process count</h1>
                    </section>
                </section>
                <section class="stack">
                    <section id="resources">
                        <h1>Resources</h1>
                    </section>
                    <section>
                        <h1>Intros</h1>
                        <ul>
                            <li><a href="http://howistart.org/posts/elixir/1">How I Start</a></li>
                            <li><a href="http://learnxinyminutes.com/docs/elixir/">Learn X in Y</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Help</h1>
                        <ul>
                            <li><a href="https://webchat.freenode.net/?channels=elixir-lang">#elixir-lang</a></li>
                            <li><a href="https://groups.google.com/forum/#!forum/elixir-lang-talk">elixir-lang-talk</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Vidoes</h1>
                        <ul>
                            <li><a href="http://elixirsips.com">elixirsips.com</a></li>
                            <li><a href="http://infoq.com">InfoQ</a></li>
                            <li><a href="https://www.youtube.com/user/ErlangSolutions">Erlang Solutions on Youtube</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Books</h1>
                        <ul>
                            <li><a href="https://pragprog.com/book/elixir/programming-elixir">Programming Elixir</a></li>
                            <li><a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir">Metaprogramming Elixir</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Websites</h1>
                        <ul>
                            <li><a href="http://elixir-lang.org">elixir-lang.org</a></li>
                            <li><a href="https://github.com/h4cc/awesome-elixir">Awesome Elixir</a></li>
                        </ul>
                    </section>
                </section>
            </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
